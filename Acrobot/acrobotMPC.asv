clear;
close all;

params_pend;

%load LQR controls
temp = load('ulqr_AB.mat', 'u_traj');
u_lqr = temp.u_traj;

%Switching Flag
swflag = 1; %1 is swingup, 2 is eq 1, 3 is eq 3


Q = diag([1,1,1,1]);
R = 5;

%%INitialize variables for linearization
syms q1 q2 q1d q2d u1 real
q = [q1; q2; q1d; q2d];

f = dx_ab_lqr(0,q,u1,p);

A_sym = jacobian(f, q);
B_sym = jacobian(f, u1);
A_fun = matlabFunction(A_sym, 'Vars', {q1, q2, q1d, q2d, u1});
B_fun = matlabFunction(B_sym, 'Vars', {q1, q2, q1d, q2d, u1});
clear q1 q2 q1d q2d u1 

dt = 0.01;
totalsim = 50;
steps = totalsim /dt;

n = 4; %states 
op = 2; %outputs q1 and q2
Np = 200; %Horizon huge cause small dt for accuracy

Rval = 5;
Qval = 10;

R = Rval * eye(1*Np);
Q = Qval * eye(op*Np);

x_traj = zeros(steps,4);
u_traj = zeros(steps,1);

eqb = [pi/2;0;0;0];
eqb2 = [pi/2;pi;0;0];

%Init states
x0 = [-pi/2;0;0;0];
u0 = 0;
x = x0;
u = u0;
x_traj(1,:) = x;
u_traj(1) = u;
u_max = 20;

%% MPC Build Equilibrium 1
%Only eq 1 for now
A = A_fun(eqb(1), eqb(2), eqb(3), eqb(4), 0);
B = B_fun(eqb(1), eqb(2), eqb(3), eqb(4), 0);
C = [1 0 0 0;
    0 1 0 0];
%Euler disc
A = eye(4) + dt*A;
B = dt * B;

Aa = [A, zeros(n,op);
      C*A, eye(op)];
Ba = [B;
      C*B];

Ca = [zeros(op,n), eye(op)];
na = length(Aa(:,1));
%Building W
W = zeros(Np*op, na);
%size(W)
Anew = Aa;
for i = 1:Np
    mrow = (i-1)*op + (1:op); %pick out 1-2,3-4,et.c. for the 2x6 matrixCa*Aa^i
    W(mrow,:) = Ca * Anew;
    Anew = Aa * Anew;
end
%size(W)

nrow = op;
nu = length(B(1,:));
ncol = nu;
%Building Z
Z = zeros(Np*nrow, Np*ncol);
for i = 1:Np
    for j = 1:i
        subblock = Ca * Aa^(i-j) * Ba;
        vrow = (i-1) * nrow + [1:nrow];
        vcol = (j-1) * ncol + [1:ncol];
        Z(vrow, vcol) = subblock;
    end
end

Ksave = (R + Z' * Q * Z) \ Z' * Q;
%% MPC For Equilibrium 2

A = A_fun(eqb(1), eqb(2), eqb(3), eqb(4), 0);
B = B_fun(eqb(1), eqb(2), eqb(3), eqb(4), 0);
C = [1 0 0 0;
    0 1 0 0];
%Euler disc
A = eye(4) + dt*A;
B = dt * B;

Aa = [A, zeros(n,op);
      C*A, eye(op)];
Ba = [B;
      C*B];

Ca = [zeros(op,n), eye(op)];
na = length(Aa(:,1));
%Building W
W = zeros(Np*op, na);
%size(W)
Anew = Aa;
for i = 1:Np
    mrow = (i-1)*op + (1:op); %pick out 1-2,3-4,et.c. for the 2x6 matrixCa*Aa^i
    W(mrow,:) = Ca * Anew;
    Anew = Aa * Anew;
end
%size(W)

nrow = op;
nu = length(B(1,:));
ncol = nu;
%Building Z
Z = zeros(Np*nrow, Np*ncol);
for i = 1:Np
    for j = 1:i
        subblock = Ca * Aa^(i-j) * Ba;
        vrow = (i-1) * nrow + [1:nrow];
        vcol = (j-1) * ncol + [1:ncol];
        Z(vrow, vcol) = subblock;
    end
end

Ksave = (R + Z' * Q * Z) \ Z' * Q;



%% Start loop
x_prev = x;
state2cnt=1;
for i = 2:steps
    
    if swflag == 1
        %disp('Swithc 1')
        %perform LQR controls for swingup
        u = u_lqr(i);
        x_prev = x;
        x = rk4_step(@(xx, uu) dx_ab_lqr(0,xx, uu, p), x, u,dt);
        x(1) = wrapToPi(x(1));
        x(2) = wrapToPi(x(2));
        x_traj(i,:) = x';
        u_traj(i) = u;
        %Condition here to switch flag when close
        if norm(x(1:2) - eqb(1:2)) < 0.05
            swflag = 2;
        end
    elseif swflag == 2
        
        %disp('Switch 2')
        %Eq1 MPC
        %Linearize A and B about eq1
        % exit when have stayed for a while
        %disp(x-x_prev)
        x_a = [x - x_prev;
            C*x];
        rp = repmat(eqb(1:2), Np, 1); %just duplicate and extend ref Np times
        delta_u = Ksave * (rp - W*x_a);
        
        u = u + delta_u(1);
        
        x_prev = x;
        x = rk4_step(@(xx, uu) dx_ab_lqr(0,xx, uu, p), x, u,dt);
        
        %x(1) = wrapToPi(x(1));
        %x(2) = wrapToPi(x(2));
        x_traj(i,:) = x';
        u_traj(i) = u;
        
        if norm(x(1:2) - eqb(1:2)) < 0.05
            state2cnt = state2cnt + 1;
            if state2cnt >= 500 %abt 5 sec
                swflag = 3;
            end
        end
    elseif swflag == 3
        x_a = [x - x_prev;
            C*x];
        rp = repmat(eqb(1:2), Np, 1); %just duplicate and extend ref Np times
        delta_u = Ksave * (rp - W*x_a);
        
        u = u + delta_u(1);
        
        x_prev = x;
        x = rk4_step(@(xx, uu) dx_ab_lqr(0,xx, uu, p), x, u,dt);
        
        %x(1) = wrapToPi(x(1));
        %x(2) = wrapToPi(x(2));
        x_traj(i,:) = x';
        u_traj(i) = u;

    else
        error('Flag value not valid');
    end 

end

%% Plotting

t = (0:steps-1) * dt;

figure;
subplot(2,1,1)
plot(t,x_traj(:,1), 'LineWidth',2)
title('Q1 cOmparison to Ref')

subplot(2,1,2)
plot(t, x_traj(:,2), 'LineWidth',2)
title('q2 Comparison to Ref')

figure;
plot(t, u_traj, 'LineWidth',2)
title('CONTROLS')
%% Animate Acrobot
L1 = p.l1;
L2 = p.l2;  
fps = 100;       
skip = round(length(t)/(fps*5));  

figure; hold on;
axis equal;
axis([-L1-L2, L1+L2, -L1-L2, L1+L2]);
grid on;
title('Acrobot Swing-Up');
xlabel('X');
ylabel('Y');

for k = 1:skip:length(t)
    q1 = x_traj(k,1);
    q2 = x_traj(k,2);
    
    %model x,y tips
    x1 = L1*cos(q1);
    y1 = L1*sin(q1);
    x2 = x1+L2*cos(q1+q2);
    y2 = y1+L2*sin(q1+q2);

    cla;
    plot([0 x1 x2],[0 y1 y2],'-o','LineWidth',2,'MarkerFaceColor','k');
    plot(0,0,'ks','MarkerSize',10,'MarkerFaceColor','k'); 
    title(sprintf('Time = %.2f s', t(k)));
    drawnow;
end